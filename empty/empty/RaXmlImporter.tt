<#@ template hostSpecific="true" debug="false" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.11.0" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="EnvDTE" #>
using System;
using System.Globalization;
using System.Xml;
using RaObjects.Objects;

namespace empty
{
    public class RaXmlImportGenerator
	{
<#
    string xsdFileName = "open-protocol-schema.xsd";
    string path = @"D:\GitHub\empty\empty";
    string xsdPath = Path.Combine(path, xsdFileName);

    string nameProject = "RaObjects";
    string nameSpace = "RaObjects.Objects";
	Project project = GetProject(nameProject);
    CodeElements codeElements = project.CodeModel.CodeElements;

    ComplexType root = InfoImporter.ImporXsdRootElement(xsdPath, codeElements, nameSpace);
	
	CreateImportElement(root);
	
    foreach (AttributionGroupInfo groupInfo in attributionGroupOrder.Values)
    {
        CreateImportAttributionGroup(groupInfo);
    }
	
#>
				
        private static void ForEachSubItems(XmlReader reader, Action doAction)
        {
            if (reader.IsEmptyElement)
            {
                return;
            }

            reader.Read();
            int depth = reader.Depth;
            do
            {
                if (reader.Depth == depth && reader.IsStartElement() && reader.NodeType == XmlNodeType.Element)
                {
                    doAction();
                }
            } while (reader.Read() && reader.Depth >= depth);
        }

		private static class ImportSimpleTypes
		{
			public static DateTime? ImportDateTimeNullable(XmlReader reader)
			{
				string value = reader.Value;
				DateTime parsedValue;
				return string.IsNullOrEmpty(value) || !DateTime.TryParse(value, out parsedValue) ? (DateTime?)null : parsedValue;
			}

			public static long? ImportLongNullable(XmlReader reader)
			{
				double? doubleValue = ImportDoubleNullable(reader);
				return doubleValue == null ? (Int64?) null : (Int64) Math.Round(doubleValue.Value, MidpointRounding.AwayFromZero);
			}

			public static double? ImportDoubleNullable(XmlReader reader)
			{
				string value = reader.Value;
				double parsedValue;
				return string.IsNullOrEmpty(value) || !double.TryParse(value, out parsedValue) ? (double?)null : parsedValue;
			}

			public static string ImportString(XmlReader reader)
			{
				return reader.Value;
			}

			public static RaDoubleValue ImportRaDoubleValue(XmlReader reader)
			{
				return new RaDoubleValue { Value = ImportDoubleNullable(reader) };
			}

			public static RaStringValue ImportRaStringValue(XmlReader reader)
			{
				return new RaStringValue { Value = ImportString(reader) };
			}

			public static RaIntValue ImportRaIntValue(XmlReader reader)
			{
				return new RaIntValue { Value = ImportLongNullable(reader) };
			}
		}
	}
}
<#+
		private Dictionary<string, AttributionGroupInfo> attributionGroupOrder = new Dictionary<string, AttributionGroupInfo>();

		private void CreateImportElement(ComplexType element)
		{
		    if (ImportSimpleTypes.CheckImportMethod(element))
		    {
				return;
		    }

#>  
        public static <#= element.ObjectType #> <#= ImportSimpleTypes.GetImportComplexElementMethod(element) #>(XmlReader reader, Action<<#= element.ObjectType #>> importAttributes)
        {
            <#= element.ObjectType #> result = new <#= element.ObjectType #>();
			importAttributes?.Invoke(result);
            ForEachSubItems(reader, () =>
            {
<#+
		    if (element.HaveSubItemsInterface)
		    {
#>
				result.SubItems.Add(Import<#= element.ObjectType #>(reader, importAttributes));
<#+ 
		    }
		    else
		    {
				CreateIfStatments(element.SubItems);
		    }
#>
            });
            return result;
        }
<#+
		    if (!element.HaveSubItemsInterface)
		    {
		        foreach (ComplexElement complexElement in element.SubItems.OfType<ComplexElement>())
		        {
		            CreateImportElement(complexElement.ComplexType);
		        }
		    }
		}

		private void CreateImportAnnonimElement(ComplexType element)
		{
#>
				ForEachSubItems(reader, () =>
				{
<#+
			CreateIfStatments(element.SubItems);
#>
				});
<#+
		}

        private void CreateImportAttributionGroup(AttributionGroupInfo attributionGroup)
        {
#> 
		private static void <#= ImportSimpleTypes.GetImportAttributionGroupMethod(attributionGroup) #>(<#= attributionGroup.ElementObjectType #> result, XmlReader reader)
		{
			if (!reader.MoveToFirstAttribute())
				return;

			do
			{
<#+ 

			CreateIfStatments(attributionGroup.Attributions);

#>
			} while (reader.MoveToNextAttribute());
			reader.MoveToElement();
		}
<#+
        }

        private void CreateIfStatments(List<IElement> elements)
        {
            bool isFirst = true;
            foreach (IElement element in elements)
            {
#>
				<#= isFirst ? "" : "else " #>if (reader.Name.Equals("<#= element.XmlName #>"))
				{
<#+
                CreateIfBody(element);
#>
				}
<#+
                isFirst = false;
            }
        }

		private void CreateIfBody(IElement element)
		{
            var simple = element as SimpleElement;
            if (simple != null)
            {
#>
					result.<#= element.ObjectName ?? String.Empty #> = <#= ImportSimpleTypes.GetImportElementMethod(element) #>(reader);
<#+
            }
			
            var complex = element as ComplexElement;
            if (complex != null)
            {
                bool haveImportAction = false;
                if (complex.Attribution != null)
                {
                    var attribution = complex.Attribution;
                    string key = attribution.XmlName + attribution.ElementObjectType;
                    if (!attributionGroupOrder.ContainsKey(key))
                    {
                        attributionGroupOrder[key] = attribution;
                    }             
					if (complex.SubItemsInAttribution || complex.IsElementContainer)
                    {
#>
					<#=ImportSimpleTypes.GetImportAttributionGroupMethod(attribution) #>(result, reader);
<#+
                    }
                    else
					{
					    haveImportAction = true;
#>
                    Action<<#= complex.ComplexType.ObjectType #>> importAttributesElement = (attribution) => <#=ImportSimpleTypes.GetImportAttributionGroupMethod(attribution) #>(attribution, reader);
<#+
                    }
                }
				if (complex.IsElementContainer)
				{
					CreateImportAnnonimElement(complex.ComplexType);
				}
				else if (!complex.SubItemsInAttribution)
				{
#>
					result.<#= element.ObjectName ?? String.Empty #> = <#= ImportSimpleTypes.GetImportElementMethod(element) #>(reader, <#= haveImportAction ? "importAttributesElement": "null" #>);
<#+				        
				}
            }
		}

        private void CreateIfStatments(List<AttributionInfo> attributions)
        {
            bool isFirst = true;
            foreach (AttributionInfo attribution in attributions)
            {
#>
				<#= isFirst ? "" : "else " #>if (reader.Name.Equals("<#= attribution.XmlName #>"))
				{
					result.<#= attribution.ObjectName #> = <#= ImportSimpleTypes.GetImportSimpleElementMethod(attribution.ObjectType) ?? ImportSimpleTypes.GetImportAttributionElementMethod(attribution.ObjectType) #>(reader);
				}
<#+
                isFirst = false;
            }
        }

	// Helpers
	private static class ImportSimpleTypes
	{
	    private static Dictionary<string, string> complexTypes = new Dictionary<string, string>();

		private static Dictionary<Type, string> simpleTypes = new Dictionary<Type, string>
		{
		    { typeof(DateTime?), nameof(ImportDateTimeNullable) },
		    { typeof(long?), nameof(ImportLongNullable) },
		    { typeof(double?), nameof(ImportDoubleNullable) },
			{ typeof(string), nameof(ImportString) },
		};

		public static DateTime? ImportDateTimeNullable(XmlReader reader)
		{
            string value = reader.Value;
            DateTime parsedValue;
            return string.IsNullOrEmpty(value) || !DateTime.TryParse(value, out parsedValue) ? (DateTime?)null : parsedValue;
		}

		public static long? ImportLongNullable(XmlReader reader)
		{
            double? doubleValue = ImportDoubleNullable(reader);
            return doubleValue == null ? (Int64?) null : (Int64) Math.Round(doubleValue.Value, MidpointRounding.AwayFromZero);
		}

	    public static double? ImportDoubleNullable(XmlReader reader)
		{
            string value = reader.Value;
            double parsedValue;
            return string.IsNullOrEmpty(value) || !double.TryParse(value, out parsedValue) ? (double?)null : parsedValue;
		}

		public static string ImportString(XmlReader reader)
		{
			return reader.Value;
		}

		/*

		public static RaDoubleValue ImportRaDoubleValue(XmlReader reader)
		{
			return new RaDoubleValue { Value = ImportDoubleNullable(reader) };
		}

		public static RaIntValue ImportRaIntValue(XmlReader reader)
		{
			return new RaIntValue { Value = ImportLongNullable(reader) };
		}

		public static RaStringValue ImportRaStringValue(XmlReader reader)
		{
			return new RaStringValue { Value = ImportString(reader) };
		}

		*/

        private static bool EqualsType(Type type, string codeTypeAsFullName)
        {
			string typeFullName = type.FullName;
			if (type.IsGenericType && type.FullName.Contains("Nullable"))
	        {
	            typeFullName = $"System.Nullable<{type.GenericTypeArguments.First().FullName}>";
	        }
	        return string.Equals(typeFullName, codeTypeAsFullName, StringComparison.InvariantCultureIgnoreCase);
        }

	    private static bool EqualsType(Type type, CodeTypeRef codeType)
	    {
			string typeFullName = type.FullName;
			if (type.IsGenericType && type.FullName.Contains("Nullable"))
	        {
	            typeFullName = $"System.Nullable<{type.GenericTypeArguments.First().FullName}>";
	        }
	        return string.Equals(typeFullName, codeType.AsFullName, StringComparison.InvariantCultureIgnoreCase);
	    }

        public static bool CheckImportMethod(ComplexType element)
        {
            if (element?.ObjectType == null)
            {
                return true;
            }
            if (complexTypes.ContainsKey(element.ObjectType))
            {
                return true;
            }
            complexTypes.Add(element.ObjectType, GetImportComplexElementMethod(element));
            return false;
        }

        public static Type GetSimpleType(string objectType)
        {
            return simpleTypes.Keys.FirstOrDefault(x => EqualsType(x, objectType));
        }

	    public static string GetImportSimpleElementMethod(Type objectType, string simpleElementAsSimpleType)
	    {
	        var methods = simpleTypes.Where(simpleType => simpleType.Key == objectType);

	        return methods.Any() 
				? $"{nameof(ImportSimpleTypes)}.{methods.FirstOrDefault().Value}" 
				: $"{nameof(ImportSimpleTypes)}.Import{simpleElementAsSimpleType}";;
	    }

	    public static string GetImportSimpleElementMethod(CodeTypeRef objectType)
	    {
	        return simpleTypes.
				Where(simpleType => EqualsType(simpleType.Key, objectType)).
				Select(simpleType => $"{nameof(ImportSimpleTypes)}.{simpleType.Value}").
				FirstOrDefault();
	    }

		public static string GetImportAttributionGroupMethod(AttributionGroupInfo attributionGroup)
		{
			return $"Import{FirstCharToUpper(attributionGroup.XmlName)}";
		}

	    public static string GetImportAttributionElementMethod(CodeTypeRef objectType)
	    {
	        string className = objectType.AsFullName.Substring(objectType.AsFullName.LastIndexOf(".") + 1);
			return $"{nameof(ImportSimpleTypes)}.Import{className}";
	    }

		public static string GetImportComplexElementMethod(ComplexType complexType)
		{
			return $"Import{complexType?.ObjectType}";
		}

		public static string GetImportElementMethod(IElement element)
		{
		    var simpleElement = element as SimpleElement;
		    if (simpleElement != null)
			{
				return GetImportSimpleElementMethod(simpleElement.SimpleType, simpleElement.AsSimpleType);
			}

		    var complexElement = element as ComplexElement;
		    if (complexElement != null)
			{
				return GetImportComplexElementMethod(complexElement.ComplexType);
			}

			return null;
		}

		private static string FirstCharToUpper(string input)
		{
			if (String.IsNullOrEmpty(input))
				return input;
			return input.First().ToString().ToUpper() + input.Substring(1);
		}
    }

    #region Structers

    public interface IElement
	{
        string XmlName { get; }
        string ObjectName { get; }
	}

	public class SimpleElement : IElement
    {
        public string XmlName { get; set; }
        public string ObjectName { get; set; }
        public Type SimpleType { get; set; }
        public string AsSimpleType { get; set; }
    }

    public class ComplexElement : IElement
    {
        public string XmlName { get; set; }
        public string ObjectName { get; set; }
        public ComplexType ComplexType { get; set; }
        public AttributionGroupInfo Attribution { get; set; }

        public bool SubItemsInAttribution => ObjectName == MapInfo.SelfObjectName;
        public bool IsElementContainer => ObjectName == MapInfo.ContainerfObjectName;
    }

    public class ComplexType
    {
        public string ObjectType { get; set; }
		
		public bool HaveSubItemsInterface { get; set; }
        public List<IElement> SubItems { get; } = new List<IElement>();
    }

    public class AttributionGroupInfo
    {
        public string XmlName { get; set; }
        public string ElementObjectType { get; set; }

        public List<AttributionInfo> Attributions { get; } = new List<AttributionInfo>();
    }

    public class AttributionInfo
    {
        public string XmlName { get; set; }
        public string ObjectName { get; set; }
        public CodeTypeRef ObjectType { get; set; }
    }

    public class XmlToObjectMap
    {
        public string XmlName;
        public string ObjectName;
    }
	
    #endregion

	public static class MapInfo
	{
	    public const string ContainerfObjectName = "~";
	    public const string SelfObjectName = ".";

		// Attributions map 
	    private static XmlToObjectMap[] aumPercentageMaps =
	    {
			new XmlToObjectMap { XmlName = "nonNettedShortAumPercentage", ObjectName = "NonNettedShortAumExposure"}, 
			new XmlToObjectMap { XmlName = "nonNettedLongAumPercentage", ObjectName = "NonNettedLongAumExposure"}, 
			new XmlToObjectMap { XmlName = "nettedShortAumPercentage", ObjectName = "NettedShortAumExposure"}, 
			new XmlToObjectMap { XmlName = "nettedLongAumPercentage", ObjectName = "NettedLongAumExposure"},
	    };

	    private static XmlToObjectMap[] assetValueMaps =
	    {
			new XmlToObjectMap { XmlName = "nonNettedShortAssetValue", ObjectName = "NonNettedShortAumExposure"}, 
			new XmlToObjectMap { XmlName = "nonNettedLongAssetValue", ObjectName = "NonNettedLongAumExposure"}, 
			new XmlToObjectMap { XmlName = "nettedShortAssetValue", ObjectName = "NettedShortAumExposure"}, 
			new XmlToObjectMap { XmlName = "nettedLongAssetValue", ObjectName = "NettedLongAumExposure"},
	    };

	    private static XmlToObjectMap[] positionsMaps =
	    {
			new XmlToObjectMap { XmlName = "numberOfLongPositions", ObjectName = "NumberOfLongPositions"}, 
			new XmlToObjectMap { XmlName = "numberOfShortPositions", ObjectName = "NumberOfShortPositions"}, 
	    };

	    private static XmlToObjectMap[] issuersMaps =
	    {
			new XmlToObjectMap { XmlName = "numberOfLongIssuers", ObjectName = "NumberOfLongIssuers"}, 
			new XmlToObjectMap { XmlName = "numberOfShortIssuers", ObjectName = "NumberOfShortIssuers"}, 
	    };
	    private static XmlToObjectMap[] valueAtRiskAttribMaps =
	    {
			new XmlToObjectMap { XmlName = "exposurePercentage", ObjectName = "PercentExposure"}, 
			new XmlToObjectMap { XmlName = "varPercentage", ObjectName = "VaR"}, 
			new XmlToObjectMap { XmlName = "cVarPercentage", ObjectName = "CvaR"}, 
	    };

	    private static XmlToObjectMap[] percentageOfExposureInCalculationMaps =
	    {
			new XmlToObjectMap { XmlName = "percentageOfLongExposureInCalculation", ObjectName = "LongExposureIncluded"}, 
			new XmlToObjectMap { XmlName = "percentageOfShortExposureInCalculation", ObjectName = "ShortExposureIncluded"},
	    };

	    private static XmlToObjectMap[] decayFactorAttribute =
	    {
			new XmlToObjectMap { XmlName = "decayFactor", ObjectName = "DecayFactor"},
	    };

	    private static XmlToObjectMap[] numberOfDaysAttribute =
	    {
			new XmlToObjectMap { XmlName = "numberOfDays", ObjectName = "LookbackPeriod"},
	    };

	    /*private static XmlToObjectMap[] betaSensitivityAttribute =
	    {
			new XmlToObjectMap { XmlName = "beta", ObjectName = "Beta"},
	    };

	    private static XmlToObjectMap[] deltaSensitivityAttribute =
	    {
			new XmlToObjectMap { XmlName = "delta", ObjectName = "Delta"},
	    };

	    private static XmlToObjectMap[] gammaVegaThetaSensitivityAttributes =
	    {
			new XmlToObjectMap { XmlName = "gamma", ObjectName = "Gamma"},
			new XmlToObjectMap { XmlName = "vega", ObjectName = "Vega"},
			new XmlToObjectMap { XmlName = "theta", ObjectName = "Theta"},
	    };

	    private static XmlToObjectMap[] basisPointChangeSensitivityAttributes =
	    {
			new XmlToObjectMap { XmlName = "cs01", ObjectName = "Cs01"},
			new XmlToObjectMap { XmlName = "dv01", ObjectName = "Dv01"},
	    };*/

	    private static XmlToObjectMap[] stressTestAttributes =
	    {
			new XmlToObjectMap { XmlName = "portfolioReturnPercentage", ObjectName = "PortfolioReturn"},
			new XmlToObjectMap { XmlName = "percentageOfLongExposureInCalculation", ObjectName = "PercentLongExposure"},
			new XmlToObjectMap { XmlName = "percentageOfShortExposureInCalculation", ObjectName = "PercentShortExposure"},
	    };

	    private static XmlToObjectMap[] historicalStressTestAttributes =
	    {
			new XmlToObjectMap { XmlName = "startDate", ObjectName = "StartDate"},
	    };
		
	    private static XmlToObjectMap[] counterpartyNameAttribute =
	    {
			new XmlToObjectMap { XmlName = "counterpartyName", ObjectName = "Number"},
	    };

	    private static XmlToObjectMap[] numberOfCustodiansAndCounterpartiesAttribute =
	    {
			new XmlToObjectMap { XmlName = "numberOfCustodiansAndCounterparties", ObjectName = "Number"},
	    };

	    private static XmlToObjectMap[] numberOfFinancingAgreementsAttribute =
	    {
			new XmlToObjectMap { XmlName = "numberOfFinancingAgreements", ObjectName = "Number"},
	    };

	    private static XmlToObjectMap[] otherAssetValueCounterpartyExposureAttributes =
	    {
			new XmlToObjectMap { XmlName = "equity", ObjectName = "Equity"},
			new XmlToObjectMap { XmlName = "longMarketValue", ObjectName = "Lmv"},
			new XmlToObjectMap { XmlName = "shortMarketValue", ObjectName = "Smv"},
			new XmlToObjectMap { XmlName = "cash", ObjectName = "Cash"},
			new XmlToObjectMap { XmlName = "openTradeEquity", ObjectName = "OteMmt"},
			new XmlToObjectMap { XmlName = "availableLiquidity", ObjectName = "AvailableLiquidity"},
			new XmlToObjectMap { XmlName = "requiredMargin", ObjectName = "RequiredMargin"},
			new XmlToObjectMap { XmlName = "longAumPercentage", ObjectName = "LongAumExposurePercent"},
			new XmlToObjectMap { XmlName = "shortAumPercentage", ObjectName = "ShortAumExposurePercent"},
	    };

	    public static Dictionary<string, XmlToObjectMap[]> AttributionGroupsMaps = new Dictionary<string, XmlToObjectMap[]>
	    {
	        { "nettedNonNettedLongShortAssetValueAttributes", assetValueMaps },
	        { "nettedNonNettedLongShortAumPercentageAttributes", aumPercentageMaps },
	        { "longShortPositionAttributes", positionsMaps },
	        { "longShortIssuerAttributes", issuersMaps },
	        { "longShortAumPercentagePositionAttributes", aumPercentageMaps.Concat(positionsMaps).ToArray() },
	        { "longShortAumPercentageIssuerAttributes", aumPercentageMaps.Concat(issuersMaps).ToArray() },

	        { "valueAtRiskAttributes", valueAtRiskAttribMaps },
	        { "percentageOfExposureInCalculationAttributes", percentageOfExposureInCalculationMaps },
	        { "decayFactorAttribute", decayFactorAttribute },
	        { "numberOfDaysAttribute", numberOfDaysAttribute },

	        /*
			{ "betaSensitivityAttribute", betaSensitivityAttribute },
	        { "deltaSensitivityAttribute", deltaSensitivityAttribute },
	        { "gammaVegaThetaSensitivityAttributes", gammaVegaThetaSensitivityAttributes },
	        { "basisPointChangeSensitivityAttributes", basisPointChangeSensitivityAttributes },
			*/

	        { "stressTestAttributes", stressTestAttributes },
	        { "historicalStressTestAttributes", stressTestAttributes.Concat(historicalStressTestAttributes).ToArray() },

	        { "counterpartyNameCounterpartyExposureAttributes", counterpartyNameAttribute.Concat(otherAssetValueCounterpartyExposureAttributes).ToArray() },
	        { "counterpartyCountCounterpartyExposureAttributes", numberOfCustodiansAndCounterpartiesAttribute.Concat(otherAssetValueCounterpartyExposureAttributes).ToArray() },
	        { "agreementCountCounterpartyExposureAttributes", numberOfFinancingAgreementsAttribute.Concat(otherAssetValueCounterpartyExposureAttributes).ToArray() },
	    };

		// Elements map 

	    private static XmlToObjectMap[] fundAndInvestorDetailsMaps =
	    {
			new XmlToObjectMap { XmlName = "fundName", ObjectName = "FundName"},
			new XmlToObjectMap { XmlName = "date", ObjectName = "Date"},
	    };

	    private static XmlToObjectMap[] equityExposureMaps =
	    {
			new XmlToObjectMap { XmlName = "totalAssetValue", ObjectName = "TotalExposure"},
			new XmlToObjectMap { XmlName = "totalAumPercentage", ObjectName = "PercentagePortfolio"},
			new XmlToObjectMap { XmlName = "totalNumberOfPositions", ObjectName = "AggregateNumberOfPositions"},

			new XmlToObjectMap { XmlName = "sectorExposure", ObjectName = "Sectors"},
			new XmlToObjectMap { XmlName = "regionExposure", ObjectName = "Region"},
			new XmlToObjectMap { XmlName = "instrumentExposure", ObjectName = "Instruments"},
			new XmlToObjectMap { XmlName = "marketCapitalExposure", ObjectName = "MarketCapitalExposure"},
			new XmlToObjectMap { XmlName = "liquidityExposure", ObjectName = "Liquidity"},
	    };

	    private static XmlToObjectMap[] sovereignInterestRateExposureMaps =
	    {
			new XmlToObjectMap { XmlName = "totalAssetValue", ObjectName = "TotalExposure"},
			new XmlToObjectMap { XmlName = "totalAumPercentage", ObjectName = "PercentagePortfolio"},
			new XmlToObjectMap { XmlName = "totalNumberOfPositions", ObjectName = "AggregateNumberOfPositions"},

			new XmlToObjectMap { XmlName = "regionExposure", ObjectName = "Region"},
			new XmlToObjectMap { XmlName = "maturityInstrumentExposure", ObjectName = "InstrumentsByMaturity"},
			new XmlToObjectMap { XmlName = "creditRatingExposure", ObjectName = "CreditRating"},
			new XmlToObjectMap { XmlName = "liquidityExposure", ObjectName = "Liquidity"},
	    };

	    private static XmlToObjectMap[] creditExposureMaps =
	    {
			new XmlToObjectMap { XmlName = "totalAssetValue", ObjectName = "TotalExposure"},
			new XmlToObjectMap { XmlName = "totalAumPercentage", ObjectName = "PercentagePortfolio"},
			new XmlToObjectMap { XmlName = "totalNumberOfIssuers", ObjectName = "AggregateNumberOfParentIssuers"},

			new XmlToObjectMap { XmlName = "sectorExposure", ObjectName = "Sectors"},
			new XmlToObjectMap { XmlName = "regionExposure", ObjectName = "Region"},
			new XmlToObjectMap { XmlName = "creditTypeExposure", ObjectName = "CreditType"},
			new XmlToObjectMap { XmlName = "instrumentExposure", ObjectName = "CreditInstrument"},
			new XmlToObjectMap { XmlName = "priceAndYieldAndSpreadExposure", ObjectName = "PriceYieldAndSpread"},
			new XmlToObjectMap { XmlName = "creditRatingExposure", ObjectName = "CreditRating"},
			new XmlToObjectMap { XmlName = "maturityExposure", ObjectName = "MaturityBuckets"},
			new XmlToObjectMap { XmlName = "ownershipConcentrationExposure", ObjectName = "ConcentrationOfOwnership"},
			new XmlToObjectMap { XmlName = "liquidityExposure", ObjectName = "Liquidity"},
	    };

	    private static XmlToObjectMap[] convertibleBondExposureMaps =
	    {
	        new XmlToObjectMap {XmlName = "totalAssetValue", ObjectName = "TotalExposure"},
	        new XmlToObjectMap {XmlName = "totalAumPercentage", ObjectName = "PercentagePortfolio"},
	        new XmlToObjectMap {XmlName = "totalNumberOfIssuers", ObjectName = "AggregateNumberOfParentIssuers"},

			new XmlToObjectMap { XmlName = "sectorExposure", ObjectName = "Sectors"},
			new XmlToObjectMap { XmlName = "regionExposure", ObjectName = "Region"},
			new XmlToObjectMap { XmlName = "instrumentExposure", ObjectName = "Instrument"},
			new XmlToObjectMap { XmlName = "derivativeSpecificExposure", ObjectName = "Derivative"},
			new XmlToObjectMap { XmlName = "creditRatingExposure", ObjectName = "CreditRating"},
			new XmlToObjectMap { XmlName = "maturityExposure", ObjectName = "MaturityBuckets"},
			new XmlToObjectMap { XmlName = "ownershipConcentrationExposure", ObjectName = "ConcentrationOfOwnership"},
			new XmlToObjectMap { XmlName = "liquidityExposure", ObjectName = "Liquidity"},
	    };

	    private static XmlToObjectMap[] currencyExposureMaps =
	    {
	        new XmlToObjectMap {XmlName = "totalAssetValue", ObjectName = "TotalExposure"},
	        new XmlToObjectMap {XmlName = "totalAumPercentage", ObjectName = "PercentagePortfolio"},
	        new XmlToObjectMap {XmlName = "totalNumberOfPositions", ObjectName = "AggregateNumberOfParentIssuers"},

			new XmlToObjectMap { XmlName = "regionCurrencyExposure", ObjectName = "RegionalCurrencies"},
			new XmlToObjectMap { XmlName = "instrumentExposure", ObjectName = "Instruments"},
			new XmlToObjectMap { XmlName = "liquidityExposure", ObjectName = "Liquidity"},
	    };

	    private static XmlToObjectMap[] realAssetExposureMaps =
	    {
	        new XmlToObjectMap {XmlName = "totalAssetValue", ObjectName = "TotalExposure"},
	        new XmlToObjectMap {XmlName = "totalAumPercentage", ObjectName = "PercentagePortfolio"},
	        new XmlToObjectMap {XmlName = "totalNumberOfPositions", ObjectName = "AggregateNumberOfParentIssuers"},

			new XmlToObjectMap { XmlName = "regionExposure", ObjectName = "Region"},
			new XmlToObjectMap { XmlName = "commodityTypeExposure", ObjectName = "CommodityType"},
			new XmlToObjectMap { XmlName = "commodityInstrumentExposure", ObjectName = "CommoditiesInstruments"},
			new XmlToObjectMap { XmlName = "realEstateExposure", ObjectName = "RealEstate"},
			new XmlToObjectMap { XmlName = "timberlandExposure", ObjectName = "Timberland"},
			new XmlToObjectMap { XmlName = "infrastructureExposure", ObjectName = "Infrastructure"},
			new XmlToObjectMap { XmlName = "liquidityExposure", ObjectName = "Liquidity"},
	    };

	    private static XmlToObjectMap[] valueAtRiskMaps =
	    {
			new XmlToObjectMap { XmlName = "calculationMethodology", ObjectName = ContainerfObjectName},

			new XmlToObjectMap { XmlName = "assetClassValueAtRisk", ObjectName = "AssetClass"},
			new XmlToObjectMap { XmlName = "regionValueAtRisk", ObjectName = "Region"},
			new XmlToObjectMap { XmlName = "sectorValueAtRisk", ObjectName = "Sector"},

			new XmlToObjectMap { XmlName = "exposureInCalculation", ObjectName = SelfObjectName},
	    };

	    private static XmlToObjectMap[] sensitivityMaps =
	    {
			/*new XmlToObjectMap { XmlName = "equity", ObjectName = "Sensivities[0]"},
			new XmlToObjectMap { XmlName = "sovereignInterestRate", ObjectName = "Sensivities"},
			new XmlToObjectMap { XmlName = "credit", ObjectName = "Sensivities[0]"},
			new XmlToObjectMap { XmlName = "convertibleBond", ObjectName = "Sensivities[0]"},
			new XmlToObjectMap { XmlName = "currency", ObjectName = "Sensivities[0]"},
			new XmlToObjectMap { XmlName = "realAsset", ObjectName = "Sensivities[0]"},*/

			new XmlToObjectMap { XmlName = "exposureInCalculation", ObjectName = SelfObjectName},
	    };

	    private static XmlToObjectMap[] stressTestMaps =
	    {
			new XmlToObjectMap { XmlName = "scenarios", ObjectName = "Scenarios"},
			new XmlToObjectMap { XmlName = "historicalStressEvents", ObjectName = "HistoricalStress"},
			new XmlToObjectMap { XmlName = "historicalStress", ObjectName = "HistoricalPortfolioStress"},
	    };

	    private static XmlToObjectMap[] counterpartyExposureMaps =
	    {
			new XmlToObjectMap { XmlName = "tradingAssets", ObjectName = "TradingAssets"},
			new XmlToObjectMap { XmlName = "treasuryAssets", ObjectName = "TreasureAssets"},
			new XmlToObjectMap { XmlName = "otherAssets", ObjectName = "OtherAssets"},
			new XmlToObjectMap { XmlName = "tradingAssetsByCounterpartyAssetSize", ObjectName = "TradingAssetsBySize"},
			new XmlToObjectMap { XmlName = "tradingAssetsByCounterpartyRegion", ObjectName = "TradingAssetsByGeography"},
			new XmlToObjectMap { XmlName = "treasuryAssetsByCounterpartyRegion", ObjectName = "TreasureAssetsByGeography"},
			new XmlToObjectMap { XmlName = "otherAssetsByCounterpartyRegion", ObjectName = "OtherAssetsByGeography"},
			new XmlToObjectMap { XmlName = "tradingAssetsByLockupProfile", ObjectName = "TradingAssetsByLockup"},

			new XmlToObjectMap { XmlName = "counterpartyAndFinancingSources", ObjectName = ContainerfObjectName},
	    };

	    private static XmlToObjectMap[] otherExposureMaps =
	    {
			new XmlToObjectMap { XmlName = "totalAssetValue", ObjectName = "TotalInvestment"},
			new XmlToObjectMap { XmlName = "totalAumPercentage", ObjectName = "PercentagePortfolio"},
			new XmlToObjectMap { XmlName = "totalNumberOfPositions", ObjectName = "AggregateNumberOfPositions"},
	    };

	    private static XmlToObjectMap[] operaMaps =
	    {
			new XmlToObjectMap { XmlName = "fundAndInvestorDetails", ObjectName = "FundAndInvestorDetails"},
			new XmlToObjectMap { XmlName = "equityExposure", ObjectName = "EquityExposure"},
			new XmlToObjectMap { XmlName = "sovereignInterestRateExposure", ObjectName = "SovereignIntRateExp"},
			new XmlToObjectMap { XmlName = "creditExposure", ObjectName = "Credit"},
			new XmlToObjectMap { XmlName = "convertibleBondExposure", ObjectName = "ConvertibleBondExposure"},
			new XmlToObjectMap { XmlName = "currencyExposure", ObjectName = "CurrencyExposure"},
			new XmlToObjectMap { XmlName = "realAssetExposure", ObjectName = "RealAssetsAndComExposure"},
			new XmlToObjectMap { XmlName = "valueAtRisk", ObjectName = "VaR"},
			new XmlToObjectMap { XmlName = "sensitivity", ObjectName = "Sensivity"},
			new XmlToObjectMap { XmlName = "stressTest", ObjectName = "StressTest"},
			new XmlToObjectMap { XmlName = "counterpartyExposure", ObjectName = "CounterParty"},
			new XmlToObjectMap { XmlName = "otherExposure", ObjectName = "OtherExposure"},
	    };

	    private static XmlToObjectMap[] calculationMethodologyMaps =
	    {
			new XmlToObjectMap { XmlName = "valueAtRiskMethodology", ObjectName = "VaRMethodology"},
			new XmlToObjectMap { XmlName = "otherValueAtRiskMethodologyDetails", ObjectName = "MethodologyDetails"},
			new XmlToObjectMap { XmlName = "decayFactor", ObjectName = SelfObjectName},
			new XmlToObjectMap { XmlName = "lookBackPeriod", ObjectName = SelfObjectName},
	    };

	    private static XmlToObjectMap[] counterpartyAndFinancingSourcesMaps =
	    {
			new XmlToObjectMap { XmlName = "unregulatedPercentageOfNetCreditCounterpartyExposure", ObjectName = "PercentAggNetCreditCpExp"},
			new XmlToObjectMap { XmlName = "uncollateralizedPercentageOfFinancing", ObjectName = "PercentFinancingUncoll"},
	    };

	    public static Dictionary<string, XmlToObjectMap[]> ComplexTypeMaps = new Dictionary<string, XmlToObjectMap[]>
	    {
			{ "opera", operaMaps },

			{ "fundAndInvestorDetails", fundAndInvestorDetailsMaps },
			{ "equityExposure", equityExposureMaps },
			{ "sovereignInterestRateExposure", sovereignInterestRateExposureMaps },
			{ "creditExposure", creditExposureMaps },
			{ "convertibleBondExposure", convertibleBondExposureMaps },
			{ "currencyExposure", currencyExposureMaps },
			{ "realAssetExposure", realAssetExposureMaps },
			{ "valueAtRisk", valueAtRiskMaps },
			{ "sensitivity", sensitivityMaps },
			{ "stressTest", stressTestMaps },
			{ "counterpartyExposure", counterpartyExposureMaps },
			{ "otherExposure", otherExposureMaps },

			{ "calculationMethodology", calculationMethodologyMaps },
			{ "counterpartyAndFinancingSources", counterpartyAndFinancingSourcesMaps },
	    };
	}

	public static class InfoImporter
	{
	    public static ComplexType ImporXsdRootElement(string xsdPath, CodeElements codeElements, string nameSpace)
	    {
	        XmlSchema xsd = PrepareSchemaSet(xsdPath);

	        ComplexType root = ImporXsdRootElement(xsd, codeElements, nameSpace);

	        return root;
	    }

	    private static XmlSchema PrepareSchemaSet(string xsdPath)
        {
            XmlSchema xsd;
            using (FileStream stream = new FileStream(xsdPath, FileMode.Open, FileAccess.Read))
            {
                xsd = XmlSchema.Read(stream, null);
            }

			XmlSchemas xsds = new XmlSchemas { xsd };
			xsds.Compile(null, true);
            return xsd;
        }

	    #region Impor Xsd elements

	    private static ComplexType ImporXsdRootElement(XmlSchema xsd, CodeElements codeElements, string nameSpace)
	    {
	        ComplexType opera = ImporXsdOperaElement(xsd, codeElements, nameSpace);
	        return opera;
	    }

	    private static ComplexType ImporXsdOperaElement(XmlSchema xsd, CodeElements codeElements, string nameSpace)
	    {
	        string rootElement = "opera";
	        string rootObjectType = "RiskAggregationData";

			XmlSchemaComplexType complexType = xsd.Elements.Values.OfType<XmlSchemaElement>().
				FirstOrDefault(x => x.Name == rootElement)?.
				ElementSchemaType as XmlSchemaComplexType;

			return ImporXsdComplexType(complexType, rootElement, rootObjectType, codeElements, nameSpace);
	    }

	    private static ComplexType ImporXsdComplexType(XmlSchemaComplexType complexType, string elementName, string objectType, CodeElements codeElements, string nameSpace)
	    {
	        XmlToObjectMap[] mapInfo = GetComplexTypeInfo(elementName);
	        if (mapInfo == null)
	        {
	            return null;
	        }

	        CodeClass codeClass = FindClass(codeElements, nameSpace, objectType);
			ComplexType objectComplexType = CreateComplexType(codeClass);

	        foreach (XmlSchemaElement xsdElement in GetXsdElements(complexType))
	        {
	            XmlToObjectMap map = mapInfo.FirstOrDefault(y => y.XmlName == xsdElement.Name);
	            if (map == null)
	                continue;

				string elementObjectName = map.ObjectName;
				string elementObjectType = IsSelfObjectName(elementObjectName) || IsContainerfObjectName(elementObjectName)
					? objectType 
					: GetFieldType(codeClass, elementObjectName, nameSpace);
				IElement element = ImportXsdElement(xsdElement, elementObjectType, elementObjectName, codeElements, nameSpace);
				objectComplexType.SubItems.Add(element);
	        }

	        return objectComplexType;
	    }

	    private static IElement ImportXsdElement(XmlSchemaElement element, string objectType, string objectFieldName, CodeElements codeElements, string nameSpace)
	    {
	        IElement result = null;
	        string name = element.Name;

	        var complexType = element.ElementSchemaType as XmlSchemaComplexType;
	        if (complexType != null)
	        {
				CodeClass codeClass = FindClass(codeElements, nameSpace, objectType);
	            if (HaveSubItemsInterface(codeClass))
	            {
					string attributionGroupName = ImportXsdAttributionGroupNameForSubElement(complexType);
					ComplexType objectComplexType = CreateComplexType(codeClass);
					result = CreateComplexElement(name, objectFieldName, objectType, attributionGroupName, objectComplexType, codeElements, nameSpace);
	            }
	            else
	            {
					string attributionGroupName = ImportXsdAttributionGroupName(complexType);
					ComplexType objectComplexType = ImporXsdComplexType(complexType, name, objectType, codeElements, nameSpace);
					result = CreateComplexElement(name, objectFieldName, objectType, attributionGroupName, objectComplexType, codeElements, nameSpace);
	            }
	        }

			var simpleType = element.ElementSchemaType as XmlSchemaSimpleType;
	        if (simpleType != null)
	        {
				Type objectSimpleType = ImportSimpleTypes.GetSimpleType(objectType);
	            result = CreatSimpleElement(name, objectFieldName, objectSimpleType, objectType);
	        }
	        return result;
	    }

	    private static IEnumerable<XmlSchemaElement> GetXsdElements(XmlSchemaComplexType complexType)
	    {
	        XmlSchemaSequence sequence = complexType?.Particle as XmlSchemaSequence ??
										(complexType?.Particle as XmlSchemaGroupRef)?.Particle as XmlSchemaSequence;

	        return sequence?.Items.OfType<XmlSchemaElement>() ?? new List<XmlSchemaElement>();
	    }

	    private static bool IsContainAttribution(string attributionGroupName)
	    {
	        return GetAttributions(attributionGroupName) != null;
	    }

	    private static string ImportXsdAttributionGroupName(XmlSchemaComplexType complexType)
	    {
	        XmlSchemaAttributeGroupRef attributeGroupRef = complexType.Attributes.OfType<XmlSchemaAttributeGroupRef>().FirstOrDefault();
	        string attributionGroupName = attributeGroupRef != null ? attributeGroupRef.RefName.Name : String.Empty;
	        return attributionGroupName;
	    }

	    private static string ImportXsdAttributionGroupNameForSubElement(XmlSchemaComplexType complexType)
	    {
	        string attributionGroupName = ImportXsdAttributionGroupName(complexType);
	        if (IsContainAttribution(attributionGroupName))
	        {
	            return attributionGroupName;
	        }

	        IEnumerable<XmlSchemaComplexType> subComplexTypes = GetXsdElements(complexType).
				Select(x => x.ElementSchemaType).
				OfType<XmlSchemaComplexType>();

	        foreach (XmlSchemaComplexType subComplexType in subComplexTypes)
	        {
				attributionGroupName = ImportXsdAttributionGroupNameForSubElement(subComplexType);
	            if (IsContainAttribution(attributionGroupName))
	            {
	                return attributionGroupName;
	            }
	        }

	        return null;
	    }
		
	    private static bool IsContainerfObjectName(string objectName)
	    {
	        return objectName == MapInfo.ContainerfObjectName;
	    }

	    private static bool IsSelfObjectName(string objectName)
	    {
	        return objectName == MapInfo.SelfObjectName;
	    }

	    #endregion

	    public static ComplexElement CreateComplexElement(string elementName, string objectName, string className, string attributionGroupName,
			ComplexType objectComplexType, CodeElements codeElements, string nameSpace)
	    {
	        CodeClass codeClass = FindClass(codeElements, nameSpace, className);
	        AttributionGroupInfo attributionGroup = CreateAttributionGroup(codeClass, attributionGroupName, GetAttributions(attributionGroupName));
	        var result = new ComplexElement
	        {
	            ComplexType = objectComplexType, 
				Attribution = attributionGroup, 
				XmlName = elementName, 
				ObjectName = objectName,
	        };
	        return result;
	    }

	    public static SimpleElement CreatSimpleElement(string elementName, string objectName, Type objectSimpleType, string objectAsSimpleType)
	    {
	        var result = new SimpleElement
	        {
	            SimpleType = objectSimpleType,
				AsSimpleType = objectAsSimpleType,
				XmlName = elementName, 
				ObjectName = objectName
	        };
	        return result;
	    }

	    public static AttributionGroupInfo CreateAttributionGroup(CodeClass parent, string attributionGroupName, IEnumerable<XmlToObjectMap> attributionMaps)
		{
		    if (attributionMaps == null)
		    {
		        return null;
		    }

			AttributionGroupInfo attributionGroup = new AttributionGroupInfo
			{
				XmlName = attributionGroupName,
				ElementObjectType = GetClassName(parent),
			};
		    foreach (XmlToObjectMap attributionMap in attributionMaps)
		    {
				CodeVariable field = FindField(parent, attributionMap.ObjectName);
		        attributionGroup.Attributions.Add(new AttributionInfo { XmlName = attributionMap.XmlName, ObjectType = field.Type, ObjectName = field.Name });
		    }
		    return attributionGroup;
		}

	    public static ComplexType CreateComplexType(CodeClass codeClass)
		{
			ComplexType elementInfo = new ComplexType
			{
				ObjectType = GetClassName(codeClass),
				HaveSubItemsInterface = HaveSubItemsInterface(codeClass),
			};
		    return elementInfo;
		}

	    public static XmlToObjectMap[] GetComplexTypeInfo(string complexTypeName)
	    {
			XmlToObjectMap[] result;
			if (complexTypeName != null && MapInfo.ComplexTypeMaps.TryGetValue(complexTypeName, out result))
			{
				return result;
			}
			return null;
	    }

	    public static IEnumerable<XmlToObjectMap> GetAttributions(string attributionGroupName)
	    {
	        XmlToObjectMap[] result;
	        if (attributionGroupName != null && MapInfo.AttributionGroupsMaps.TryGetValue(attributionGroupName, out result))
	        {
	            return result;
	        }
	        if (!string.IsNullOrEmpty(attributionGroupName))
	        {

	        }
	        return null;
	    }

	    private static bool HaveSubItemsInterface(CodeClass codeClass)
	    {
	        return codeClass.ImplementedInterfaces.OfType<CodeInterface>().Any(x => x.Name == "IMovedSubItems" || x.Name == "ISubItems");
	    }

	    public static string GetClassName(string className, string nameSpace)
	    {
			return className.Replace($"{nameSpace}.", string.Empty);
	    }

		public static string GetClassName(CodeClass codeClass)
		{
			return codeClass.Name.Replace($"{codeClass.Namespace}.", string.Empty);
		}

	    private static string GetFieldType(CodeClass codeClass, string propName, string nameSpace)
	    {
	        CodeVariable field = FindField(codeClass, propName);
	        return field == null ? null : GetClassName(field.Type.AsFullName, nameSpace);
	    }

		private static CodeVariable FindField(CodeClass codeClass, string propName)
		{
		    CodeVariable field = codeClass.Members.OfType<CodeVariable>().FirstOrDefault(x => x.Name == propName);
		    if (field == null)
		    {

		    }
			return field;
		}

		private static Dictionary<string, CodeClass> classCache = new Dictionary<string, CodeClass>();
		public static CodeClass FindClass(CodeElements elements, string nameSpace, string className)
		{
		    CodeClass codeClass;
		    if (classCache.TryGetValue(className, out codeClass))
		    {
		        return codeClass;
		    }

			List<CodeClass> result = new List<CodeClass>();
			FindClasses(elements,className,nameSpace,result,false);
			classCache.Add(className, result.FirstOrDefault());
		    codeClass = result.FirstOrDefault();
			if (codeClass == null)
		    {

		    }
			return codeClass;
		}

		private static void FindClasses(CodeElements elements, string className,string searchNamespace,List<CodeClass> result,bool isNamespaceOk)
		{
			if (elements == null || result.Any())
			{
				return;
			}

			foreach (CodeElement element in elements)
			{       
				if(element is EnvDTE.CodeNamespace)
				{
					EnvDTE.CodeNamespace ns = element as EnvDTE.CodeNamespace;
					if(ns != null)
					{
						if (ns.FullName == searchNamespace)
							FindClasses(ns.Members, className,searchNamespace,result,true);
						else
							FindClasses(ns.Members, className,searchNamespace,result,false);
					}
				}
				else if(element is CodeClass && isNamespaceOk)
				{
					CodeClass c = element as CodeClass;
					if (c != null)
					{
						if (c.Name.Equals(className))
						{
							result.Add(c);
						}

						FindClasses(c.Members, className,searchNamespace,result,true);
					}
				}
			}
		}
	}

	private Project GetProject(string projectName)
	{
		// Get DTE
		var serviceProvider = Host as IServiceProvider;
		var dte = serviceProvider.GetService(typeof(DTE)) as DTE;

		Project project = dte.Solution.Projects.OfType<Project>().FirstOrDefault(x => x.Name == projectName);

		return project;
	}

#>